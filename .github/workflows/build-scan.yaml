name: Build & Security Scan

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
  # INFO: Daily security scan
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch: {}

env:
  JAVA_HOME: "" # INFO: Force JAVA_HOME to be empty, so gradle will use the sdkman java version
  DOCKER_REPOSITORY: ${{ vars.DOCKER_REPOSITORY }}
  DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

permissions:
  contents: read
  actions: read
  checks: write
  issues: write
  packages: read
  pull-requests: write

jobs:
  prepare_tag:
    name: Setup Tag
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.bump_version.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v6

      - name: Bump version and push tag
        id: bump_version
        uses: anothrNick/github-tag-action@1.75.0
        env:
          GITHUB_TOKEN: ${{ github.token }}
          DEFAULT_BUMP: patch
          DRY_RUN: true

  build_scan:
    runs-on: ubuntu-latest
    needs: [prepare_tag]
    permissions:
      contents: read
      actions: read
      checks: write
      issues: write
      packages: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v6

      - name: Cache SDKMAN
        uses: actions/cache@v4
        with:
          path: ~/.sdkman
          key: sdkman-${{ runner.os }}-${{ hashFiles('.sdkmanrc') }}

      - name: Install SDKMAN
        uses: sdkman/sdkman-action@b1f9b696c79148b66d3d3a06f7ea801820318d0f

      # INFO: Tell Gradle which JDK to use *regardless* of what happens to JAVA_HOME
      - name: Point Gradle at the SDKMAN JDK
        run: echo "JAVA_HOME=$HOME/.sdkman/candidates/java/current" >> $GITHUB_ENV

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5

      - name: Build with Makefile
        run: make build
        env:
          GITHUB_USERNAME: x-access-token
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action/linux@v2
        if: always()
        with:
          files: |
            build/test-results/**/*.xml

      - name: Publish Checkstyle Results
        uses: jwgmeligmeyling/checkstyle-github-action@v1
        with:
          path: "build/reports/checkstyle/main.xml"

      - name: Archive test report
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: Test report
          path: build/reports/tests

      - name: Add coverage to PR
        if: github.event_name == 'pull_request'
        uses: madrapps/jacoco-report@v1.7.2
        with:
          paths: ${{ github.workspace }}/build/reports/jacoco/test/jacocoTestReport.xml
          token: ${{ secrets.GITHUB_TOKEN }}
          min-coverage-overall: 80
          min-coverage-changed-files: 80

      - name: Verify Test Coverage
        if: github.event_name == 'pull_request'
        run: make test-coverage-verification
        continue-on-error: false

      - name: Build Docker Image
        env:
          DOCKER_IMAGE: "${{ env.DOCKER_REPOSITORY }}:${{ needs.prepare_tag.outputs.VERSION }}"
        run: ./gradlew bootBuildImage --imageName=${{ env.DOCKER_IMAGE }}

      # INFO: Pull the latest published image from Docker Hub for vulnerability comparison.
      # This avoids rebuilding the base branch and reuses the already-published image from main.
      - name: Login to Docker Hub
        if: github.event_name == 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: Pull latest image for comparison
        id: pull_latest
        if: github.event_name == 'pull_request'
        env:
          LATEST_IMAGE: "${{ env.DOCKER_REPOSITORY }}:latest"
        run: |
          if docker pull ${{ env.LATEST_IMAGE }}; then
            echo "Successfully pulled baseline image for comparison"
          else
            echo "No baseline image found, skipping baseline comparison"
          fi
        continue-on-error: true

      - name: Scan baseline image with Trivy
        id: scan_baseline
        if: github.event_name == 'pull_request' && steps.pull_latest.outcome == 'success'
        uses: aquasecurity/trivy-action@0.33.1
        env:
          LATEST_IMAGE: "${{ env.DOCKER_REPOSITORY }}:latest"
        with:
          image-ref: ${{ env.LATEST_IMAGE }}
          format: "json"
          output: "baseline-trivy-results.json"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      - name: Scan current build with Trivy
        uses: aquasecurity/trivy-action@0.33.1
        env:
          DOCKER_IMAGE: "${{ env.DOCKER_REPOSITORY }}:${{ needs.prepare_tag.outputs.VERSION }}"
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}
          format: "table"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      - name: Scan current build with Trivy (JSON for comparison)
        id: scan_current
        if: github.event_name == 'pull_request'
        uses: aquasecurity/trivy-action@0.33.1
        env:
          DOCKER_IMAGE: "${{ env.DOCKER_REPOSITORY }}:${{ needs.prepare_tag.outputs.VERSION }}"
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}
          format: "json"
          output: "current-trivy-results.json"
          severity: "HIGH,CRITICAL"
          exit-code: "0"

      - name: Compare vulnerabilities and fail on new ones
        if: github.event_name == 'pull_request' && steps.scan_baseline.outcome == 'success' && steps.scan_current.outcome == 'success'
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os

          def extract_vulns(json_file):
              """Extract unique vulnerability IDs from trivy JSON output"""
              try:
                  with open(json_file, 'r') as f:
                      data = json.load(f)
                  vulns = set()
                  for result in data.get('Results', []):
                      for vuln in result.get('Vulnerabilities', []):
                          vuln_id = vuln.get('VulnerabilityID', '')
                          if vuln_id:
                              vulns.add(vuln_id)
                  return vulns
              except (FileNotFoundError, json.JSONDecodeError, KeyError):
                  return set()

          baseline_file = 'baseline-trivy-results.json'
          current_file = 'current-trivy-results.json'

          # Validate baseline file exists and is not empty
          if not os.path.exists(baseline_file) or os.path.getsize(baseline_file) == 0:
              print("⚠️  Baseline scan results are missing or empty. Skipping comparison.")
              print("   This may happen if the baseline image download failed or the scan failed.")
              print("   Current build vulnerabilities will be shown but comparison is skipped.")
              sys.exit(0)

          # Validate current scan file exists and is not empty
          if not os.path.exists(current_file) or os.path.getsize(current_file) == 0:
              print("❌ Current scan results are missing or empty. Cannot perform comparison.")
              print("   This indicates the current build scan failed or was skipped.")
              print("   Please check the scan step logs for errors.")
              sys.exit(1)

          # Validate current scan file is valid JSON
          try:
              with open(current_file, 'r') as f:
                  json.load(f)  # Just validate it's valid JSON
          except json.JSONDecodeError as e:
              print(f"❌ Current scan results are invalid JSON. Cannot perform comparison.")
              print(f"   JSON decode error: {e}")
              print("   The scan may have failed or produced invalid output.")
              sys.exit(1)
          except Exception as e:
              print(f"❌ Unexpected error reading current scan results: {e}")
              sys.exit(1)

          baseline_vulns = extract_vulns(baseline_file)
          current_vulns = extract_vulns(current_file)

          # Validate baseline has valid data
          if not baseline_vulns and os.path.getsize(baseline_file) > 0:
              # File exists but has no vulnerabilities - this is valid
              print("ℹ️  Baseline scan found no vulnerabilities (empty baseline).")
          elif not baseline_vulns:
              print("⚠️  Baseline scan results are invalid. Skipping comparison.")
              sys.exit(0)

          new_vulns = current_vulns - baseline_vulns
          fixed_vulns = baseline_vulns - current_vulns

          print(f"Baseline vulnerabilities: {len(baseline_vulns)}")
          print(f"Current vulnerabilities: {len(current_vulns)}")
          print(f"New vulnerabilities: {len(new_vulns)}")
          print(f"Fixed vulnerabilities: {len(fixed_vulns)}")

          # Write counts to files for PR comment evaluation
          with open('new-vulns-count.txt', 'w') as f:
              f.write(str(len(new_vulns)))
          with open('current-vulns-count.txt', 'w') as f:
              f.write(str(len(current_vulns)))

          if new_vulns:
              print("\n❌ NEW VULNERABILITIES DETECTED:")
              for vuln in sorted(new_vulns):
                  print(f"  - {vuln}")
              sys.exit(1)
          elif fixed_vulns:
              print("\n✅ Some vulnerabilities were fixed:")
              for vuln in sorted(fixed_vulns):
                  print(f"  - {vuln}")
          else:
              print("\n✅ No new vulnerabilities detected")
          EOF

      - name: Evaluate vulnerability status for PR comment
        if: github.event_name == 'pull_request'
        id: vuln_eval
        run: |
          # Check if comparison actually ran and completed successfully
          if [ -f new-vulns-count.txt ] && [ -f current-vulns-count.txt ]; then
            NEW_COUNT=$(cat new-vulns-count.txt)
            PR_COUNT=$(cat current-vulns-count.txt)
            COMPARISON_RAN=true
          else
            # No comparison occurred - don't set counts for comment
            NEW_COUNT=0
            PR_COUNT=0
            COMPARISON_RAN=false
          fi
          echo "new_count=${NEW_COUNT}" >> $GITHUB_OUTPUT
          echo "pr_count=${PR_COUNT}" >> $GITHUB_OUTPUT
          echo "comparison_ran=${COMPARISON_RAN}" >> $GITHUB_OUTPUT

      - name: Comment on PR about existing vulnerabilities
        if: github.event_name == 'pull_request' && steps.vuln_eval.outputs.comparison_ran == 'true'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: security-scan
          recreate: true
          message: |
            ### Security scan
            - No new HIGH/CRITICAL vulnerabilities introduced.
            - ${{ steps.vuln_eval.outputs.pr_count }} existing HIGH/CRITICAL vulnerabilities remain in the PR image.

            Check the workflow run's Summary for details.

      - name: Run Trivy vulnerability scanner (fail on HIGH/CRITICAL for scheduled scans)
        if: github.event_name == 'schedule'
        uses: aquasecurity/trivy-action@0.33.1
        env:
          DOCKER_IMAGE: "${{ env.DOCKER_REPOSITORY }}:${{ needs.prepare_tag.outputs.VERSION }}"
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}
          format: "table"
          severity: "HIGH,CRITICAL"
          exit-code: "1"
